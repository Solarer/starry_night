#!/usr/bin/env python
# coding: utf-8
'''
Usage:
    starry_night -c <confFile> [<image>... | -d <directory> | -l <posFile>] [options]

Options:
                    If none
    <image>         Image file(s)
    <directory>     Directory that contains image files. (Recursive!)
    <posFile>       File that contains Positions and timestamps to analyse
    -t TIME         Force to use this time and do not parse image name
    -c Camera       Provide a camera config file or use one of these names: 'GTC', 'Magic' or 'CTA'
    -v              Visual output
    -s              Save output to files
    --kernel=<k>    Try different kernel sizes
    --function=<f>  Function used for calculation of response ('Grad','Sobel','LoG', 'All')
                    Using option '--ratescan' implies 'LoG'. [default: LoG]

    --cam           Show camera image
    --ratescan      Create ratescan-like plot of visibility threshold
    --response      Plot response vs Magnitude in log scale 
    --cloudmap      Create cloud map of the sky
    --single        Display information for each single image
    --airmass      Calculate airmass absorbtion
    --version       Show version.
    --debug         debug it [default: False]
'''

from __future__ import print_function
from docopt import docopt
import pkg_resources
import logging
import os
import sys
import time
import numpy as np
import pandas as pd
import configparser
import matplotlib.pyplot as plt
import skimage.filters
from matplotlib import rc, cm
from datetime import datetime, timedelta
from multiprocessing import Pool
from functools import partial
from scipy.optimize import curve_fit
from re import split
from collections import Counter

from starry_night import skycam
from IPython import embed

def wrapper(config, celestialObjects, args, img):
    return skycam.process_image(skycam.getImageDict(img, config), celestialObjects, config, args)

__version__ = pkg_resources.require('starry_night')[0].version
directory = os.path.join(os.environ['HOME'], '.starry_night')
if not os.path.exists(directory):
    os.makedirs(directory)

# create handler for file and console output
logfile_path = os.path.join(
    directory, 'starry_night.log'
    )
logfile_handler = logging.FileHandler(filename=logfile_path)
logstream_handler = logging.StreamHandler()
formatter = logging.Formatter(
    fmt='%(asctime)s - %(levelname)s - %(name)s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
)
formatter.converter = time.gmtime  # use utc in log
logfile_handler.setFormatter(formatter)
logstream_handler.setFormatter(formatter)

# setup logging
logging.basicConfig(
        handlers = [
            logfile_handler,
            logstream_handler,
            ],
        level=logging.INFO,
        )
logging.captureWarnings(True)


def main(args):
    log = logging.getLogger('starry_night')
    log.info('starry_night started')
    log.info('version: {}'.format(__version__))
    
    if args['--debug']:
        log.info('DEBUG MODE - NOT FOR REGULAR USE')
        log.setLevel(logging.DEBUG)
        log.debug('started starry_night in debug mode')
        #print(args)

    config = configparser.RawConfigParser()
    log.debug('Parsing config file: {}'.format(args['-c']))
    # c!=0 if config was read successfully
    if '.' in args['-c'] or '/' in args['-c']:
        c = len(config.read(args['-c']))
    else:
        c = len(config.read(pkg_resources.resource_filename(
            'starry_night', 'data/{}_cam.config'.format(args['-c']))
        ))
    if c == 0:
        log.error('Unable to parse config file. Does the file exist?')
        sys.exit(1)

    log.debug('Parsing Catalogue')
    celestialObjects = skycam.star_planets_sun_moon_dict()

    log.debug('Aquire Image(s)')
    results = list()
    if not args['<image>']:
        # download current image(s) from URL
        singleMode = True
        log.info('Downloading image from {}'.format(config['properties']['url']))
        try:
            rawImg = skycam.downloadImg(
                config['properties']['url'],
                timeout=5,
            )
            log.debug('Download finished')
        except:
            log.error('Download of image failed')
            raise

        for img in rawImg:
            if type(img) is not dict:
                images = dict({
                        'img': img,
                        'timestamp': datetime.utcnow() +
                        timedelta(minutes=float(config['properties']['timeoffset']))
                })
            else:
                images = img
                print(images['timestamp'])
                images['timestamp'] += timedelta(minutes=float(config['properties']['timeoffset']))
                print(images['timestamp'])

            results.append(
                    skycam.process_image(images, celestialObjects, config, args)
            )

    else:
        # use image(s) provided by the user
        if len(args['<image>']) == 1:
            singleMode = True
            if args['-t'] is not None:
                images['timestamp'] = datetime(args['-t'])
        else:
            singleMode = False
        imgCount = len(args['<image>'])

        log.info('Processing {} images.'.format(imgCount))
        par = partial(wrapper, config, celestialObjects, args)

        # don't use multiprocessing in debug mode
        if args['--debug']:
            for img in args['<image>']:
                results.append(par(img))
        else:
            pool = Pool(maxtasksperchild=50)
            results = pool.map(par, args['<image>'])
            pool.close()
            pool.join()

    # drop all 'None' elements (image processing was aborted because of high sun)
    # and merge the remaining files into one multiindex dataframe
    i=0
    while i<len(results):
        if not results[i]:
            results.pop(i)
        else:
            i+=1
    
    imgCount = len(results)
    log.info('{} images were processed successfully.'.format(imgCount))

    # no more processing if one or less images were processed successfully
    #if len(results) <= 1:
    #    sys.exit(0)
    star_results = list(map(lambda x: x[0], results))
    star_timestamps = list(map(lambda x: x[1], results))

    df = pd.concat(star_results, keys=star_timestamps, names=['date','HIP'])
    del results
    del star_results
    del star_timestamps

    df.sortlevel(inplace=True)
    #d.loc[(slice(None), 746), :]
    #d.loc[(slice(None), 746),:]['response3'].plot.hist(10)

    mean = df.mean(level=1)[df.count(level=1)['vmag'].values > len(df.index.levels[0])/2]
    std = df.std(level=1)[df.count(level=1)['vmag'].values > len(df.index.levels[0])/2]

    df.reset_index(inplace=True)
    c = Counter(df.HIP)
    new_df = pd.concat( [df.query('HIP==%d'%key) for key, val in c.items() if val > 40 ] )
    embed()

    if args['--airmass']:
        if not args['--debug']:
            log.error('This option is only available in debug mode')
        else:
            '''
            new_df['erwartet'] = 10**skycam.lin(new_df.vmag.values, popt[0], popt[1])
            new_df['diff'] = new_df['response'] / new_df['erwartet']
            new_df['diff2'] = (new_df['response'] / new_df['erwartet'])**(1/new_df['erwartet'])

            a = df.query('altitude > {}'.format(80*np.pi/180)).groupby('HIP').filter(lambda x : len(x) > 10).groupby('HIP').response.mean()
            a = df.join(a, on='HIP', rsuffix='r').dropna()
            '''



            fig = plt.figure()
            ax = fig.add_subplot(111)
            vmag_to_plot = np.arange(0, 6.1, 0.5)
            color = cm.jet(np.linspace(0,1,len(vmag_to_plot)))

            grouped = df.groupby('HIP')
            #remove stars that do not have enough variance in their altitude
            filtered_df = grouped.filter(lambda x: x.altitude.max() > 70*np.pi/180 and x.altitude.min() < 35*np.pi/180)
            for i, vmag in enumerate(vmag_to_plot):
                c = color[i]
                # get star with magnitude closest to 'vmag'
                # ignore 2 stars with HIP because they are not good examples for the plot
                to_plot = filtered_df.query(
                        'HIP == {}'.format(
                        filtered_df.ix[(filtered_df.query('HIP != 75312 and HIP != 52686').vmag-vmag).abs().sort(inplace=False).index[0]].HIP
                    )
                ).sort_values('altitude')

                if abs(to_plot.vmag.max() - vmag)>=0.5:
                    # dont plot, if magnitude differs too much
                    continue
               
                maxVal = to_plot.query('altitude > {}'.format(np.percentile(to_plot.altitude, 90))).response.mean()
                popt, pcov = curve_fit(skycam.transmission2, to_plot.altitude.values, to_plot.response.values/maxVal)

                ax.scatter(x=to_plot['altitude']/np.pi*180, y=to_plot['response'], c=c, label='vmag = {}'.format(to_plot.vmag.max()))
                ax.plot(to_plot.altitude/np.pi*180, maxVal*skycam.transmission2(to_plot.altitude.values, popt[0]), c=c)
                print(vmag, to_plot.HIP.max(), popt)

            ax.semilogy()
            ax.grid()
            ax.legend(loc='upper right')
            plt.show()

            fig = plt.figure()
            ax = fig.add_subplot(111)
            r = []
            for group in filtered_df.groupby('HIP'):
                maxVal = group[1].query('altitude > {}'.format(np.percentile(group[1].altitude, 90))).response.mean()
                x = group[1].sort_values('altitude').altitude.values
                y = group[1].sort_values('altitude').response.values/maxVal
                popt, pcov = curve_fit(skycam.transmission2, x, y)
                r.append((popt[0], np.sqrt(pcov[0]), maxVal, group[1].vmag.values.max()))

            r = np.array(r)
            popt, pcov = curve_fit(skycam.lin, r[:,3], r[:,0], sigma=r[:,1])
            plt.errorbar(r[:,3], r[:,0], yerr=r[:,1], linestyle='', color='blue', marker='o', ms=2)
            x = np.linspace(-1,8,5)
            y = skycam.lin(x, popt[0], popt[1])
            plt.plot(x,y, color='red', label='linear regression')
            plt.grid()
            plt.legend()
            plt.show()
            print(popt, pcov)




    def logf(x, m, b):
        return 10**(m*x+b)

    fit_stars = df.query('0 < vmag < {}'.format(float(config['image']['vmaglimit'])))
    popt, pcov = curve_fit(logf, fit_stars.vmag.values, fit_stars.response.values, sigma=1/fit_stars.vmag.values, p0=(-0.2, 2))
    x = np.linspace(-3+fit_stars.vmag.min(), fit_stars.vmag.max(), 20)
    y = logf(x, popt[0], popt[1]-0.3)
    lim = (split('\\s*,\\s*', config['image']['visibleupperlimit']), split('\\s*,\\s*', config['image']['visiblelowerlimit']))
    y1 = 10**(x*float(lim[1][0]) + float(lim[1][1]))
    y2 = 10**(x*float(lim[0][0]) + float(lim[0][1]))
    sys.exit(0)


    if args['--response']:
        fig = plt.figure(figsize=(16,9))
        ax = plt.subplot(111)
        ax.axhspan(ymin=11**2/255**2, ymax=13**2/255**2, color='red', alpha=0.5, label='Old threshold - Gradient')
        mean.plot.scatter(x='vmag',y='response', yerr=std['response'].values, color='blue', ax=ax, logy=True, grid=True, vmin=0, vmax=1, label='{} Response'.format(args['--function']))
        #mean.plot.scatter(x='vmag',y='response_grad', yerr=std['response_grad'].values, color='red', ax=ax, logy=True, grid=True, label='Gradient Response')
        #ax.set_xlim((-1, max(mean['vmag'])+0.5))
        ax.set_ylim(bottom=10**(np.log10(np.nanpercentile(mean.response.values,10.0))//1-1),
            top=10**(np.log10(np.nanpercentile(mean.response.values,99.9))//1+1))
        ax.plot(x,y)
        ax.plot(x,y1)
        ax.plot(x,y2)
        ax.legend(loc='best')
        ax.set_ylabel('Kernel Response')
        ax.set_xlabel('Star Magnitude')
        plt.show()
        if args['-s']:
            plt.savefig('response_{}_mean.pdf'.format(args['--function']))
        if args['-v']:
            plt.show()
        plt.close('all')
    
    

    fig = plt.figure(figsize=(16,9))
    ax = plt.subplot(111)
    #if args['--function'] == 'Grad':
    #ax.axhspan(ymin=11**2/255**2, ymax=13**2/255**2, color='red', alpha=0.5, label='old threshold range')
    df.loc[df.index.get_level_values(0).unique()[0]].plot.scatter(
            x='vmag',y='response', color='green', ax=ax, logy=True, grid=True, label='Kernel Response - no Moon')
    df.loc[df.index.get_level_values(0).unique()[1]].plot.scatter(
            x='vmag',y='response', color='red', ax=ax, logy=True, grid=True, label='Kernel Response - Moon')
    df.loc[df.index.get_level_values(0).unique()[2]].plot.scatter(
            x='vmag',y='response', color='k', ax=ax, logy=True, grid=True, label='Kernel Response - cloud')
    ax.set_ylim((1e-5,1))
    plt.show()




''' Main Loop '''
if __name__ == '__main__':
    args = docopt(
        doc=__doc__,
        version=__version__,
        )
    try:
        main(args)
    except (KeyboardInterrupt, SystemExit):
        logging.getLogger().info('Exit')
    except:
        raise
