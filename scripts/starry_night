#!/usr/bin/env python
# coding: utf-8
'''
Usage:
    starry_night -c <confFile> [-f <image>... | -d <directory> | -l <posFile>] [options]

Options:
                    If none
    -f IMAGE        Image file(s)
    -d DIRECTORY    Directory that contains image files. (Recursive!)
    -l POSFILE      File that contains Positions and timestamps to analyse
    -t TIME         Image time
    -c CONFIG       Configuration file
    -v              Visual output

    --version       Show version.
    --debug         debug it [default: False]
'''

from __future__ import print_function
import pkg_resources
import logging
import os
import sys
import time
from docopt import docopt
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
import configparser
from pkg_resources import resource_filename
import skimage.filters
from scipy.ndimage.measurements import label

from starry_night import skycam
from IPython import embed


__version__ = pkg_resources.require('starry_night')[0].version
directory = os.path.join(os.environ['HOME'], '.starry_night')
if not os.path.exists(directory):
    os.makedirs(directory)

# setup logging
log = logging.getLogger('starry_night')
log.setLevel(logging.DEBUG)
logfile_path = os.path.join(
    directory, 'starry_night.log'
    )
# create handler for file and console output
logfile_handler = logging.FileHandler(filename=logfile_path)
logstream_handler = logging.StreamHandler()
logfile_handler.setLevel(logging.DEBUG)
logstream_handler.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    fmt='%(asctime)s - %(levelname)s - %(name)s | %(message)s',
    datefmt='%H:%M:%S',
)
formatter.converter = time.gmtime  # use utc in log
logfile_handler.setFormatter(formatter)
logstream_handler.setFormatter(formatter)
log.addHandler(logfile_handler)
log.addHandler(logstream_handler)
logging.captureWarnings(True)




def main(args):
    log.info('starry_night started')
    log.info('version: {}'.format(__version__))
    
    if args['--debug']:
        log.info('DEBUG MODE - NOT FOR REGULAR USE')
        log.setLevel(logging.DEBUG)
        log.debug('started starry_night in debug mode')


    print(args)
    # TODO: read config file to obtain URL and stuff
    log.debug('Parsing config file: {}'.format(args['-c']))
    config = configparser.RawConfigParser()
    config.read(resource_filename(
        'starry_night', '../data/{}'.format(args['-c']))
    )


    # download current image from URL
    if args['-f'] is None:
        log.info('Do an online analysis of an image file')
        try:
            img = skycam.downloadImg(
                config['properties']['url'],
                timeout=5,
            )
            log.debug('Download finished')
        except:
            log.error('Download of image failed')
            raise

        time = datetime.utcnow()
    # use the image provided by the user
    elif len(args['-f']) == 1:
        log.info('Do an offline analysis of an image file')
        img, time = skycam.loadImageAndTime(args['-f'][0], crop=config['crop'], fmt=config['image']['timestamp'])
        time = time + timedelta(minutes=-5)
        log.debug('Opened image: {}'.format(args['-f']))
    else:
        log.error('Can not process a list of files yet')
        sys.exit(1)
        

    # create cropping array to mask unneccessary image regions.
    crop_mask = skycam.crop_mask(img, config['crop'])

    # store image and additional data in dict
    image = dict({
            'img': img,
            'timestamp': time,
            'log': np.zeros(1),
            })
    log.debug('Image time: {}'.format(time))

    log.debug('Creating Observer')
    obs = skycam.obs_setup(time)
    log.debug('Parsing Catalogue')
    stars, planets, moon, sun = skycam.star_planets_moon_sun_dataframes(
            obs, 
            cam=config['image'],
            )

    rem = skycam.filter_catalogue(stars, rng = float(config['image']['minAngleBetweenStars']))

    # calculate x and y position
    log.debug('Calculate x and y')
    stars['x'], stars['y'] = skycam.horizontal2image(stars.azimuth, stars.altitude, cam=config['image'])
    planets['x'], planets['y'] = skycam.horizontal2image(planets.azimuth, planets.altitude, cam=config['image'])
    moon['x'], moon['y'] = skycam.horizontal2image(moon['azimuth'], moon['altitude'], cam=config['image'])



    log.debug('Apply image filters')
    grad = (img - np.roll(img, 1, axis=0)).clip(min=0)**2 + (img - np.roll(img, 1, axis=1)).clip(min=0)**2
    sobel = skimage.filters.sobel(img).clip(min=0)
    gauss = skimage.filters.gaussian(img, sigma=1)
    lap = skimage.filters.laplace(gauss, ksize=3).clip(min=0)
    grad[crop_mask] = 0
    sobel[crop_mask] = 0
    lap[crop_mask] = 0


    
    log.debug('Calculate Filter response')
    stars['response'] = stars.apply(lambda s : skycam.findLocalMaxValue(grad, s.x, s.y, 2), axis=1)
    stars['response2'] = stars.apply(lambda s : skycam.findLocalMaxValue(sobel, s.x, s.y, 2), axis=1)
    stars['response3'] = stars.apply(lambda s : skycam.findLocalMaxValue(lap, s.x, s.y, 2), axis=1)
    '''
    stars = pd.concat([stars, stars.apply(
            lambda s : skycam.findLocalMaxPos(grad, s.x, s.y, 2),
            axis=1)],axis=1)
    '''

    gradList = list()
    sobelList = list()
    lapList = list()
    gradList2 = list()
    sobelList2 = list()
    lapList2 = list()

    ax = plt.subplot(111)
    ax.imshow(img, cmap='gray')
    stars.plot.scatter(ax=ax, x='x', y='y', color='red')
    (stars.loc[rem]).plot.scatter(ax=ax, x='x', y='y', color='green')
    plt.show()
    embed()
    stars.query('275 < y < 280 & 140 < x 150').head()
    '''
    response = np.logspace(-4,0,500)
    for resp in response:
        labeled, labelCnt = label(grad>resp)
        stars['visible'] = stars.response > resp
        gradList.append((skycam.calc_star_percentage(0, stars, -1), np.sum(grad > resp), labelCnt, sum(stars.visible)))
        labeled, labelCnt = label(sobel>resp)
        stars['visible'] = stars.response2 > resp
        sobelList.append((skycam.calc_star_percentage(0, stars, -1), np.sum(sobel > resp), labelCnt, sum(stars.visible)))
        labeled, labelCnt = label(lap>resp)
        stars['visible'] = stars.response3 > resp
        lapList.append((skycam.calc_star_percentage(0, stars, -1), np.sum(lap > resp), labelCnt, sum(stars.visible)))

    gradList = np.array(gradList)
    sobelList = np.array(sobelList)
    lapList = np.array(lapList)
    gradList2 = np.array(gradList2)
    sobelList2 = np.array(sobelList2)
    lapList2 = np.array(lapList2)

    fig = plt.figure(figsize=(19.2,10.8))
    ax1 = fig.add_subplot(111)
    plt.xscale('log')
    plt.grid()
    ax1.plot(response, sobelList[:,0], marker='x', c='blue', label='Sobel Kernel - Percent')
    ax1.plot(response, lapList[:,0], marker='x', c='red', label='LoG Kernel - Percent')
    ax1.plot(response, gradList[:,0], marker='x', c='green', label='Square Gradient - Percent')
    ax1.set_ylabel('')
    ax1.legend(loc='center left')

    ax2 = ax1.twinx()
    #ax2.plot(response, gradList[:,1], marker='o', c='green', label='Square Gradient - Pixcount')
    #ax2.plot(response, sobelList[:,1], marker='o', c='blue', label='Sobel Kernel - Pixcount')
    #ax2.plot(response, lapList[:,1], marker='o', c='red', label='LoG Kernel - Pixcount')
    ax2.plot(response, gradList[:,2], marker='s', c='green', label='Square Gradient - Clustercount')
    ax2.plot(response, sobelList[:,2], marker='s', c='blue', label='Sobel Kernel - Clustercount')
    ax2.plot(response, lapList[:,2], marker='s', c='red', label='LoG Kernel - Clustercount')
    ax2.legend(loc='upper right')
    ax2.set_ylim((0,16000))
    plt.savefig('rateScan.pdf')
    embed()

    if args['-v']:
    fig = plt.figure()
    ax = fig.add_subplot(121)
    stars.query('visible == True').plot.scatter(ax=ax, x='x', y='y', color='green')
    stars.query('visible == False').plot.scatter(ax=ax, x='x', y='y', color='red')
    stars.plot.scatter(x='vmag', y='response2', color='red', grid=True)
    plt.show()
        fig = plt.figure()
        ax = fig.add_subplot(121)
        ax.imshow(-lap/0.05, cmap='Greys_r', interpolation='none')
        ax2 = fig.add_subplot(122)
        ax2.imshow(-grad, cmap='Greys_r', interpolation='none')
        plt.legend()
        fig = plt.figure()
        ax3 = fig.add_subplot(121)
        ax3.imshow(img, cmap='Greys_r', interpolation='none')
        ax4 = fig.add_subplot(122)
        ax4.imshow(img, cmap='Greys_r', interpolation='none')
        ax.grid()
        ax2.grid()
        ax3.grid()
        ax4.grid()

        fig = plt.figure()
        plt.hist(lap.flatten(), bins=100, range=(0,0.05))
        plt.show()
        pass
    '''




''' Main Loop '''
if __name__ == '__main__':
    args = docopt(
        doc=__doc__,
        version=__version__,
        )
    try:
        main(args)
    except (KeyboardInterrupt, SystemExit):
        log.info('Exit')
    except:
        raise
