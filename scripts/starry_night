#!/usr/bin/env python
# coding: utf-8
'''
Usage:
    starry_night -c <confFile> [<image>... | -d <directory> | -l <posFile>] [options]

Options:
                    If none
    <image>         Image file(s)
    <directory>     Directory that contains image files. (Recursive!)
    <posFile>       File that contains Positions and timestamps to analyse
    -t TIME         Force to use this time and do not parse image name
    -c CONFIG       Configuration file
    -v              Visual output

    --ratescan      Create ratescan-like plot of visibility threshold
    --version       Show version.
    --debug         debug it [default: False]
'''

from __future__ import print_function
import pkg_resources
import logging
import os
import sys
import time
from docopt import docopt
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
import configparser
from pkg_resources import resource_filename
import skimage.filters
from scipy.ndimage.measurements import label
from dask import delayed, compute

from starry_night import skycam
from IPython import embed


__version__ = pkg_resources.require('starry_night')[0].version
directory = os.path.join(os.environ['HOME'], '.starry_night')
if not os.path.exists(directory):
    os.makedirs(directory)

# setup logging
log = logging.getLogger('starry_night')
log.setLevel(logging.DEBUG)
logfile_path = os.path.join(
    directory, 'starry_night.log'
    )
# create handler for file and console output
logfile_handler = logging.FileHandler(filename=logfile_path)
logstream_handler = logging.StreamHandler()
logfile_handler.setLevel(logging.DEBUG)
logstream_handler.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    fmt='%(asctime)s - %(levelname)s - %(name)s | %(message)s',
    datefmt='%H:%M:%S',
)
formatter.converter = time.gmtime  # use utc in log
logfile_handler.setFormatter(formatter)
logstream_handler.setFormatter(formatter)
log.addHandler(logfile_handler)
log.addHandler(logstream_handler)
logging.captureWarnings(True)




def main(args):
    log.info('starry_night started')
    log.info('version: {}'.format(__version__))
    
    if args['--debug']:
        log.info('DEBUG MODE - NOT FOR REGULAR USE')
        log.setLevel(logging.DEBUG)
        log.debug('started starry_night in debug mode')


    print(args)
    # TODO: read config file to obtain URL and stuff
    log.debug('Parsing config file: {}'.format(args['-c']))
    config = configparser.RawConfigParser()
    config.read(resource_filename(
        'starry_night', '../data/{}'.format(args['-c']))
    )


    # download current image from URL
    if not args['<image>']:
        log.info('Downloading image from {}'.format(config['properties']['url']))
        try:
            img = skycam.downloadImg(
                config['properties']['url'],
                timeout=5,
            )
            log.debug('Download finished')
        except:
            log.error('Download of image failed')
            raise

        time = datetime.utcnow()


    # use the image(s) provided by the user
    elif len(args['<image>']) == 1:
        log.info('Do an offline analysis of an image file')
        img, time = skycam.loadImageAndTime(args['<image>'][0], crop=config['crop'], fmt=config['image']['timestamp'])
        if args['-t'] is not None:
            time = time + timedelta(minutes=float(config['properties']['timeoffset']))
        else:
            time = datetime(args['-t'])
        log.info('Opened image: {} with time'.format(args['<image>'], time))

    else:
        log.info('Processing {} images.'.format(len(args['<image>'])))

        output = list()
        for f in args['<image>']:
            a = delayed(skycam.loadImageAndTime)(f, crop=config['crop'], fmt=config['image']['timestamp'], dask_key_name='three')
            #result = delayed(skycam.process_image)(a, config)
            #output.append(a)

        print(output)
        result = compute(*output)

    # store image and additional data in dict
    images = dict({
            'img': img,
            'timestamp': time,
            })
    stars = skycam.process_image(images, config)

    '''
    stars = pd.concat([stars, stars.apply(
            lambda s : skycam.findLocalMaxPos(lap, s.x, s.y, 2),
            axis=1)],axis=1)
    '''


    if args['--ratescan']:
        gradList = list()
        sobelList = list()
        lapList = list()

        response = np.logspace(-4,0,500)
        for resp in response:
            labeled, labelCnt = label(grad>resp)
            stars['visible'] = stars.response > resp
            gradList.append((skycam.calc_star_percentage(0, stars, -1), np.sum(grad > resp), labelCnt, sum(stars.visible)))
            labeled, labelCnt = label(sobel>resp)
            stars['visible'] = stars.response2 > resp
            sobelList.append((skycam.calc_star_percentage(0, stars, -1), np.sum(sobel > resp), labelCnt, sum(stars.visible)))
            labeled, labelCnt = label(lap>resp)
            stars['visible'] = stars.response3 > resp
            lapList.append((skycam.calc_star_percentage(0, stars, -1), np.sum(lap > resp), labelCnt, sum(stars.visible)))

        gradList = np.array(gradList)
        sobelList = np.array(sobelList)
        lapList = np.array(lapList)

        fig = plt.figure(figsize=(19.2,10.8))
        ax1 = fig.add_subplot(111)
        plt.xscale('log')
        plt.grid()
        ax1.plot(response, sobelList[:,0], marker='x', c='blue', label='Sobel Kernel - Percent')
        ax1.plot(response, lapList[:,0], marker='x', c='red', label='LoG Kernel - Percent')
        ax1.plot(response, gradList[:,0], marker='x', c='green', label='Square Gradient - Percent')
        ax1.set_ylabel('')
        ax1.legend(loc='center left')

        ax2 = ax1.twinx()
        #ax2.plot(response, gradList[:,1], marker='o', c='green', label='Square Gradient - Pixcount')
        #ax2.plot(response, sobelList[:,1], marker='o', c='blue', label='Sobel Kernel - Pixcount')
        #ax2.plot(response, lapList[:,1], marker='o', c='red', label='LoG Kernel - Pixcount')
        ax2.plot(response, gradList[:,2], marker='s', c='green', label='Square Gradient - Clustercount')
        ax2.plot(response, sobelList[:,2], marker='s', c='blue', label='Sobel Kernel - Clustercount')
        ax2.plot(response, lapList[:,2], marker='s', c='red', label='LoG Kernel - Clustercount')
        ax2.legend(loc='upper right')
        ax2.set_ylim((0,16000))
        plt.savefig('rateScan.pdf')

    if args['-v']:
        fig = plt.figure()
        ax = fig.add_subplot(111)

        ax.imshow(img, cmap='gray')
        
        plt.show()
        '''
        ax = fig.add_subplot(121)
        stars.query('visible == True').plot.scatter(ax=ax, x='x', y='y', color='green')
        stars.query('visible == False').plot.scatter(ax=ax, x='x', y='y', color='red')
        stars.plot.scatter(x='vmag', y='response2', color='red', grid=True)

        fig = plt.figure()
        ax = fig.add_subplot(121)
        ax.imshow(-images['lap']/0.05, cmap='Greys_r', interpolation='none')
        ax2 = fig.add_subplot(122)
        ax2.imshow(-images['grad'], cmap='Greys_r', interpolation='none')
        plt.legend()
        fig = plt.figure()
        ax3 = fig.add_subplot(121)
        ax3.imshow(images['img'], cmap='Greys_r', interpolation='none')
        ax4 = fig.add_subplot(122)
        ax4.imshow(images['img'], cmap='Greys_r', interpolation='none')
        ax.grid()
        ax2.grid()
        ax3.grid()
        ax4.grid()

        fig = plt.figure()
        plt.hist(images['lap'].flatten(), bins=100, range=(0,0.05))
        plt.show()
        '''
    



''' Main Loop '''
if __name__ == '__main__':
    args = docopt(
        doc=__doc__,
        version=__version__,
        )
    try:
        main(args)
    except (KeyboardInterrupt, SystemExit):
        log.info('Exit')
    except:
        raise
