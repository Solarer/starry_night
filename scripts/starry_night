#!/usr/bin/env python
# coding: utf-8
'''
Usage:
    starry_night -c <confFile> [<image>... | -d <directory> | -l <posFile>] [options]

Options:
                    If none
    <image>         Image file(s)
    <directory>     Directory that contains image files. (Recursive!)
    <posFile>       File that contains Positions and timestamps to analyse
    -t TIME         Force to use this time and do not parse image name
    -c CONFIG       Configuration file
    -v              Visual output
    -s              Save output to files

    --ratescan      Create ratescan-like plot of visibility threshold
    --response      Show response Magnitude log plot
    --cloudmap     Create cloud map of the sky
    --version       Show version.
    --debug         debug it [default: False]
'''

from __future__ import print_function
from docopt import docopt
import pkg_resources
import logging
import os
import sys
import time
import matplotlib.pyplot as plt
from matplotlib import rc
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
import configparser
import skimage.filters
from multiprocessing import Pool
from functools import partial

from starry_night import skycam
from IPython import embed

def wrapper(config, celestialObjects, args, img):
    return skycam.process_image(skycam.getImageDict(img, config), celestialObjects, config, args)

__version__ = pkg_resources.require('starry_night')[0].version
directory = os.path.join(os.environ['HOME'], '.starry_night')
if not os.path.exists(directory):
    os.makedirs(directory)

# setup logging
log = logging.getLogger('starry_night')
log.setLevel(logging.DEBUG)
logfile_path = os.path.join(
    directory, 'starry_night.log'
    )
# create handler for file and console output
logfile_handler = logging.FileHandler(filename=logfile_path)
logstream_handler = logging.StreamHandler()
logfile_handler.setLevel(logging.INFO)
logstream_handler.setLevel(logging.INFO)
formatter = logging.Formatter(
    fmt='%(asctime)s - %(levelname)s - %(name)s | %(message)s',
    datefmt='%H:%M:%S',
)
formatter.converter = time.gmtime  # use utc in log
logfile_handler.setFormatter(formatter)
logstream_handler.setFormatter(formatter)
log.addHandler(logfile_handler)
log.addHandler(logstream_handler)
logging.captureWarnings(True)




def main(args):
    log.info('starry_night started')
    log.info('version: {}'.format(__version__))
    
    if args['--debug']:
        log.info('DEBUG MODE - NOT FOR REGULAR USE')
        log.setLevel(logging.DEBUG)
        log.debug('started starry_night in debug mode')


    print(args)
    # TODO: read config file to obtain URL and stuff
    log.debug('Parsing config file: {}'.format(args['-c']))
    config = configparser.RawConfigParser()
    config.read(pkg_resources.resource_filename(
        'starry_night', '../data/{}'.format(args['-c']))
    )

    log.debug('Parsing Catalogue')
    celestialObjects = skycam.star_planets_sun_moon_dict()

    # aquire image(s)
    results = list()
    if not args['<image>']:
        # download current image from URL
        singleMode = True
        log.info('Downloading image from {}'.format(config['properties']['url']))
        try:
            img = skycam.downloadImg(
                config['properties']['url'],
                timeout=5,
            )
            log.debug('Download finished')
        except:
            log.error('Download of image failed')
            raise

        images = dict({
                'img': img,
                'timestamp': datetime.utcnow() +
                timedelta(minutes=float(config['properties']['timeoffset']))
        })
        results.append(
                skycam.process_image(images, celestialObjects, config, args)
        )


    else:
        # use (multiple) image(s) provided by the user
        if len(args['<image>']) == 1:
            singleMode = True
            if args['-t'] is not None:
                images['timestamp'] = datetime(args['-t'])
        else:
            singleMode = False
        imgCount = len(args['<image>'])
        log.info('Processing {} images.'.format(imgCount))

        par = partial(wrapper, config, celestialObjects, args)

        # don't use multiprocessing in debug mode
        if args['--debug']:
            for img in args['<image>']:
                results.append(par(img))
        else:
            pool = Pool(maxtasksperchild=50)
            results = pool.map(par, args['<image>'])
            pool.close()
            pool.join()

    #log.info('Filtering catalogue')
    #rem = filter_catalogue(stars, rng = float(config['image']['minAngleBetweenStars']))

    # drop all 'None' elements (image processing was aborted because of high sun)
    # and merge the remaining files into one multiindex dataframe
    i=0
    while i<len(results):
        if not results[i]:
            results.pop(i)
        else:
            i+=1

    if len(results) == 0:
        sys.exit(0)
    star_results = list(map(lambda x: x[0], results))
    star_timestamps = list(map(lambda x: x[1], results))

    df = pd.concat(star_results, keys=star_timestamps)
    del star_results
    del star_timestamps
    #d.loc[(slice(None), 746), :]
    #d.loc[(slice(None), 746),:]['response3'].plot.hist(10)
    #embed()
    
    

''' Main Loop '''
if __name__ == '__main__':
    args = docopt(
        doc=__doc__,
        version=__version__,
        )
    try:
        main(args)
    except (KeyboardInterrupt, SystemExit):
        log.info('Exit')
    except:
        raise
