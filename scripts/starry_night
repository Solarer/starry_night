#!/usr/bin/env python
# coding: utf-8
'''
Usage:
    starry_night -c <confFile> [<image>... | -d <directory> | -l <posFile>] [options]

Options:
                    If none
    <image>         Image file(s)
    <directory>     Directory that contains image files. (Recursive!)
    <posFile>       File that contains Positions and timestamps to analyse
    -t TIME         Force to use this time and do not parse image name
    -c CONFIG       Configuration file
    -v              Visual output
    -s              Save output to files

    --ratescan      Create ratescan-like plot of visibility threshold
    --response      Show response Magnitude log plot
    --cloud_map     Create cloud map of the sky
    --version       Show version.
    --debug         debug it [default: False]
'''

from __future__ import print_function
import pkg_resources
import logging
import os
import sys
import time
from docopt import docopt
import matplotlib.pyplot as plt
from matplotlib import rc
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
import configparser
from pkg_resources import resource_filename
import skimage.filters
from scipy.ndimage.measurements import label
from multiprocessing import Pool
from functools import partial

from starry_night import skycam
from IPython import embed

global response
def wrapper(config, celestialObjects, args, img):
    return skycam.process_image(skycam.getImageDict(img, config), celestialObjects, config, args)

__version__ = pkg_resources.require('starry_night')[0].version
directory = os.path.join(os.environ['HOME'], '.starry_night')
if not os.path.exists(directory):
    os.makedirs(directory)

# setup logging
log = logging.getLogger('starry_night')
log.setLevel(logging.DEBUG)
logfile_path = os.path.join(
    directory, 'starry_night.log'
    )
# create handler for file and console output
logfile_handler = logging.FileHandler(filename=logfile_path)
logstream_handler = logging.StreamHandler()
logfile_handler.setLevel(logging.DEBUG)
logstream_handler.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    fmt='%(asctime)s - %(levelname)s - %(name)s | %(message)s',
    datefmt='%H:%M:%S',
)
formatter.converter = time.gmtime  # use utc in log
logfile_handler.setFormatter(formatter)
logstream_handler.setFormatter(formatter)
log.addHandler(logfile_handler)
log.addHandler(logstream_handler)
logging.captureWarnings(True)




def main(args):
    log.info('starry_night started')
    log.info('version: {}'.format(__version__))
    
    if args['--debug']:
        log.info('DEBUG MODE - NOT FOR REGULAR USE')
        log.setLevel(logging.DEBUG)
        log.debug('started starry_night in debug mode')


    print(args)
    # TODO: read config file to obtain URL and stuff
    log.debug('Parsing config file: {}'.format(args['-c']))
    config = configparser.RawConfigParser()
    config.read(resource_filename(
        'starry_night', '../data/{}'.format(args['-c']))
    )

    log.debug('Parsing Catalogue')
    celestialObjects = skycam.star_planets_sun_moon_dict()

    # aquire image(s)
    output = list()
    if not args['<image>']:
        # download current image from URL
        singleMode = True
        log.info('Downloading image from {}'.format(config['properties']['url']))
        try:
            img = skycam.downloadImg(
                config['properties']['url'],
                timeout=5,
            )
            log.debug('Download finished')
        except:
            log.error('Download of image failed')
            raise

        images = dict({
                'img': img,
                'timestamp': datetime.utcnow(),
                })
        results.append(
                skycam.process_image(images, celestialObjects, config)
        )


    else:
        # use (multiple) image(s) provided by the user
        if len(args['<image>']) == 1:
            singleMode = True
            if args['-t'] is not None:
                images['timestamp'] = datetime(args['-t'])
        else:
            singleMode = False
        imgCount = len(args['<image>'])
        log.info('Processing {} images.'.format(imgCount))

        pool = Pool()
        par = partial(wrapper, config, celestialObjects, args)
        #embed()
        results = pool.imap(par, args['<image>'])
        pool.close()
        pool.join()


    
    

    #log.info('Filtering catalogue')
    #rem = filter_catalogue(stars, rng = float(config['image']['minAngleBetweenStars']))
    
    if args['--response']:
        a = results[0].result()
        lap = a[1]['lap']
        stars = a[0]

        stars = pd.concat([stars, stars.apply(
                lambda s : skycam.findLocalMaxPos(lap, s.x, s.y, 2),
                axis=1)],axis=1)
        stars2 = stars.sort_values('vmag').drop_duplicates(subset=['maxX', 'maxY'], keep='first')

        fig = plt.figure(figsize=(4,3))
        ax = plt.subplot(111)
        stars2.plot.scatter(x='vmag',y='response3',ax=ax, logy=True, grid=True)
        ax.set_xlim((0,6))
        ax.set_ylim((10,2e4))
        ax.set_ylabel('Kernel Response')
        ax.set_xlabel('Star Magnitude')
        
        font = {'size'   : 16, 'weight':'bold'}
        rc('font', **font)






    if args['-v']:
        if False:
            fig = plt.figure()
            ax = fig.add_subplot(111)
            vmin = np.nanpercentile(image, 0.)
            vmax = np.nanpercentile(image, 100.)
            ax.imshow(image,cmap='gray',vmin=vmin,vmax=vmax)
            

            ax.imshow(images['img'], cmap='gray')
            
            plt.show()
        else:
            '''
            for res in results:
                r = res.result()
                fig = plt.figure()
                ax = fig.add_subplot(111)
                vmin = np.nanpercentile(r[1]['img'], 0.5)
                vmax = np.nanpercentile(r[1]['img'], 99.5)
                ax.imshow(r[1]['img'],cmap='gray',vmin=vmin,vmax=vmax)
                ax.scatter(r[0].x.values, r[0].y.values)
                print(r[1]['timestamp'])
                plt.show()
            '''


        '''
        ax = fig.add_subplot(121)
        stars.query('visible == True').plot.scatter(ax=ax, x='x', y='y', color='green')
        stars.query('visible == False').plot.scatter(ax=ax, x='x', y='y', color='red')
        stars.plot.scatter(x='vmag', y='response2', color='red', grid=True)

        fig = plt.figure()
        ax = fig.add_subplot(121)
        ax.imshow(-images['lap']/0.05, cmap='Greys_r', interpolation='none')
        ax2 = fig.add_subplot(122)
        ax2.imshow(-images['grad'], cmap='Greys_r', interpolation='none')
        plt.legend()
        fig = plt.figure()
        ax3 = fig.add_subplot(121)
        ax3.imshow(images['img'], cmap='Greys_r', interpolation='none')
        ax4 = fig.add_subplot(122)
        ax4.imshow(images['img'], cmap='Greys_r', interpolation='none')
        ax.grid()
        ax2.grid()
        ax3.grid()
        ax4.grid()

        fig = plt.figure()
        plt.hist(images['lap'].flatten(), bins=100, range=(0,0.05))
        plt.show()
        '''
    



''' Main Loop '''
if __name__ == '__main__':
    args = docopt(
        doc=__doc__,
        version=__version__,
        )
    try:
        main(args)
    except (KeyboardInterrupt, SystemExit):
        log.info('Exit')
    except:
        raise
