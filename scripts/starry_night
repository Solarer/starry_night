#!/usr/bin/env python
# coding: utf-8
'''
Usage:
    starry_night -c <confFile> [<image>... | -d <directory> | -l <posFile>] [options]

Options:
                    If none
    <image>         Image file(s)
    <directory>     Directory that contains image files. (Recursive!)
    <posFile>       File that contains Positions and timestamps to analyse
    -t TIME         Force to use this time and do not parse image name
    -c Camera       Provide a camera config file or use one of these names: 'GTC', 'Magic' or 'CTA'
    -v              Visual output
    -s              Save output to files
    --kernel=<k>    Try different kernel sizes

    --ratescan      Create ratescan-like plot of visibility threshold
    --response      Show response Magnitude log plot
    --cloudmap      Create cloud map of the sky
    --version       Show version.
    --debug         debug it [default: False]
'''

from __future__ import print_function
from docopt import docopt
import pkg_resources
import logging
import os
import sys
import time
import matplotlib.pyplot as plt
from matplotlib import rc
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
import configparser
import skimage.filters
from multiprocessing import Pool
from functools import partial

from starry_night import skycam
from IPython import embed

def wrapper(config, celestialObjects, args, img):
    return skycam.process_image(skycam.getImageDict(img, config), celestialObjects, config, args)

__version__ = pkg_resources.require('starry_night')[0].version
directory = os.path.join(os.environ['HOME'], '.starry_night')
if not os.path.exists(directory):
    os.makedirs(directory)

# create handler for file and console output
logfile_path = os.path.join(
    directory, 'starry_night.log'
    )
logfile_handler = logging.FileHandler(filename=logfile_path)
logstream_handler = logging.StreamHandler()
formatter = logging.Formatter(
    fmt='%(asctime)s - %(levelname)s - %(name)s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
)
formatter.converter = time.gmtime  # use utc in log
logfile_handler.setFormatter(formatter)
logstream_handler.setFormatter(formatter)

# setup logging
logging.basicConfig(
        handlers = [
            logfile_handler,
            logstream_handler,
            ],
        level=logging.INFO,
        )
logging.captureWarnings(True)


def main(args):
    log = logging.getLogger('starry_night')
    log.info('starry_night started')
    log.info('version: {}'.format(__version__))
    
    if args['--debug']:
        log.info('DEBUG MODE - NOT FOR REGULAR USE')
        log.setLevel(logging.DEBUG)
        log.debug('started starry_night in debug mode')
        # print(args)

    # TODO: read config file
    config = configparser.RawConfigParser()
    if '.' in args['-c'] or '/' in args['-c']:
        log.debug('Parsing config file: {}'.format(args['-c']))
        config.read(args['-c'])
    else:
        config.read(pkg_resources.resource_filename(
            'starry_night', 'data/{}_cam.config'.format(args['-c']))
        )

    log.debug('Parsing Catalogue')
    celestialObjects = skycam.star_planets_sun_moon_dict()

    log.debug('Aquire Image(s)')
    results = list()
    if not args['<image>']:
        # download current image(s) from URL
        singleMode = True
        log.info('Downloading image from {}'.format(config['properties']['url']))
        try:
            rawImg = skycam.downloadImg(
                config['properties']['url'],
                timeout=5,
            )
            log.debug('Download finished')
        except:
            log.error('Download of image failed')
            raise

        for img in rawImg:
            if type(img) is not dict:
                images = dict({
                        'img': img,
                        'timestamp': datetime.utcnow() +
                        timedelta(minutes=float(config['properties']['timeoffset']))
                })
            else:
                images = img
                print(images['timestamp'])
                images['timestamp'] += timedelta(minutes=float(config['properties']['timeoffset']))
                print(images['timestamp'])

            results.append(
                    skycam.process_image(images, celestialObjects, config, args)
            )


    else:
        # use image(s) provided by the user
        if len(args['<image>']) == 1:
            singleMode = True
            if args['-t'] is not None:
                images['timestamp'] = datetime(args['-t'])
        else:
            singleMode = False
        imgCount = len(args['<image>'])

        log.info('Processing {} images.'.format(imgCount))
        par = partial(wrapper, config, celestialObjects, args)

        # don't use multiprocessing in debug mode
        if args['--debug']:
            for img in args['<image>']:
                results.append(par(img))
        else:
            pool = Pool(maxtasksperchild=50)
            results = pool.map(par, args['<image>'])
            pool.close()
            pool.join()

    # drop all 'None' elements (image processing was aborted because of high sun)
    # and merge the remaining files into one multiindex dataframe
    i=0
    while i<len(results):
        if not results[i]:
            results.pop(i)
        else:
            i+=1

    if len(results) == 0:
        sys.exit(0)
    star_results = list(map(lambda x: x[0], results))
    star_timestamps = list(map(lambda x: x[1], results))

    df = pd.concat(star_results, keys=star_timestamps)
    del star_results
    del star_timestamps
    #d.loc[(slice(None), 746), :]
    #d.loc[(slice(None), 746),:]['response3'].plot.hist(10)
    embed()
    
    

''' Main Loop '''
if __name__ == '__main__':
    args = docopt(
        doc=__doc__,
        version=__version__,
        )
    try:
        main(args)
    except (KeyboardInterrupt, SystemExit):
        logging.getLogger().info('Exit')
    except:
        raise
