#!/usr/bin/env python
# coding: utf-8
'''
Usage:
    starry_night -c <confFile> [<image>... | -d <directory> | -l <posFile>] [options]

Options:
                    If none
    <image>         Image file(s)
    <directory>     Directory that contains image files. (Recursive!)
    <posFile>       File that contains Positions and timestamps to analyse
    -t TIME         Force to use this time and do not parse image name
    -c Camera       Provide a camera config file or use one of these names: 'GTC', 'Magic' or 'CTA'
    -v              Visual output
    -s              Save output to files
    --kernel=<k>    Try different kernel sizes
    --function=<f>  Function used for calculation of response ('Grad','Sobel','LoG', 'All')
                    Using option '--ratescan' implies 'LoG'. [default: LoG]

    --cam           Show camera image
    --ratescan      Create ratescan-like plot of visibility threshold
    --response      Plot response vs Magnitude in log scale 
    --cloudmap      Create cloud map of the sky
    --single        Display information for each single image
    --version       Show version.
    --debug         debug it [default: False]
'''

from __future__ import print_function
from docopt import docopt
import pkg_resources
import logging
import os
import sys
import time
import matplotlib.pyplot as plt
from matplotlib import rc
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
import configparser
import skimage.filters
from multiprocessing import Pool
from functools import partial
from scipy.optimize import curve_fit
from re import split
from collections import Counter

from starry_night import skycam
from IPython import embed

def wrapper(config, celestialObjects, args, img):
    return skycam.process_image(skycam.getImageDict(img, config), celestialObjects, config, args)

__version__ = pkg_resources.require('starry_night')[0].version
directory = os.path.join(os.environ['HOME'], '.starry_night')
if not os.path.exists(directory):
    os.makedirs(directory)

# create handler for file and console output
logfile_path = os.path.join(
    directory, 'starry_night.log'
    )
logfile_handler = logging.FileHandler(filename=logfile_path)
logstream_handler = logging.StreamHandler()
formatter = logging.Formatter(
    fmt='%(asctime)s - %(levelname)s - %(name)s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
)
formatter.converter = time.gmtime  # use utc in log
logfile_handler.setFormatter(formatter)
logstream_handler.setFormatter(formatter)

# setup logging
logging.basicConfig(
        handlers = [
            logfile_handler,
            logstream_handler,
            ],
        level=logging.INFO,
        )
logging.captureWarnings(True)


def main(args):
    log = logging.getLogger('starry_night')
    log.info('starry_night started')
    log.info('version: {}'.format(__version__))
    
    if args['--debug']:
        log.info('DEBUG MODE - NOT FOR REGULAR USE')
        log.setLevel(logging.DEBUG)
        log.debug('started starry_night in debug mode')
        #print(args)

    config = configparser.RawConfigParser()
    log.debug('Parsing config file: {}'.format(args['-c']))
    # c!=0 if config was read successfully
    if '.' in args['-c'] or '/' in args['-c']:
        c = len(config.read(args['-c']))
    else:
        c = len(config.read(pkg_resources.resource_filename(
            'starry_night', 'data/{}_cam.config'.format(args['-c']))
        ))
    if c == 0:
        log.error('Unable to parse config file. Does the file exist?')
        sys.exit(1)

    log.debug('Parsing Catalogue')
    celestialObjects = skycam.star_planets_sun_moon_dict()

    log.debug('Aquire Image(s)')
    results = list()
    if not args['<image>']:
        # download current image(s) from URL
        singleMode = True
        log.info('Downloading image from {}'.format(config['properties']['url']))
        try:
            rawImg = skycam.downloadImg(
                config['properties']['url'],
                timeout=5,
            )
            log.debug('Download finished')
        except:
            log.error('Download of image failed')
            raise

        for img in rawImg:
            if type(img) is not dict:
                images = dict({
                        'img': img,
                        'timestamp': datetime.utcnow() +
                        timedelta(minutes=float(config['properties']['timeoffset']))
                })
            else:
                images = img
                print(images['timestamp'])
                images['timestamp'] += timedelta(minutes=float(config['properties']['timeoffset']))
                print(images['timestamp'])

            results.append(
                    skycam.process_image(images, celestialObjects, config, args)
            )

    else:
        # use image(s) provided by the user
        if len(args['<image>']) == 1:
            singleMode = True
            if args['-t'] is not None:
                images['timestamp'] = datetime(args['-t'])
        else:
            singleMode = False
        imgCount = len(args['<image>'])

        log.info('Processing {} images.'.format(imgCount))
        par = partial(wrapper, config, celestialObjects, args)

        # don't use multiprocessing in debug mode
        if args['--debug']:
            for img in args['<image>']:
                results.append(par(img))
        else:
            pool = Pool(maxtasksperchild=50)
            results = pool.map(par, args['<image>'])
            pool.close()
            pool.join()

    # drop all 'None' elements (image processing was aborted because of high sun)
    # and merge the remaining files into one multiindex dataframe
    i=0
    while i<len(results):
        if not results[i]:
            results.pop(i)
        else:
            i+=1
    
    imgCount = len(results)
    log.info('{} images were processed successfully.'.format(imgCount))

    # no more processing if one or less images were processed successfully
    #if len(results) <= 1:
    #    sys.exit(0)
    star_results = list(map(lambda x: x[0], results))
    star_timestamps = list(map(lambda x: x[1], results))

    df = pd.concat(star_results, keys=star_timestamps, names=['date','HIP'])
    del results
    del star_results
    del star_timestamps

    df.sortlevel(inplace=True)
    #d.loc[(slice(None), 746), :]
    #d.loc[(slice(None), 746),:]['response3'].plot.hist(10)

    mean = df.mean(level=1)[df.count(level=1)['vmag'].values > len(df.index.levels[0])/2]
    std = df.std(level=1)[df.count(level=1)['vmag'].values > len(df.index.levels[0])/2]

    df.reset_index(inplace=True)
    c = Counter(df.HIP)
    new_df = pd.concat( [df.query('HIP==%d'%key) for key, val in c.items() if val > 40 ] )
    embed()

    if args['--altitude']:
        def lin(x,m,b):
            return m*x+b

        popt = [-0.40012162,  2.6433107 ] # idealer fit, mit 10Â° zenith
        #x = mean.altitude.values
        #y = np.log10(mean.response.values)
        #popt, pcov = curve_fit(lin, x, y)
        new_df['erwartet'] = 10**lin(new_df.vmag.values, popt[0], popt[1])
        new_df['diff'] = new_df['response'] / new_df['erwartet']
        new_df['diff2'] = (new_df['response'] / new_df['erwartet'])**(1/new_df['erwartet'])


        from matplotlib.pyplot import cm
        color=cm.seismic(np.linspace(0,1,65))

        def quad(x,a):
            return -a*(x[0]-np.pi/2)**2 + x[1]
        def quad2(x,r):
            return -np.sqrt(r*121/30)*(x-np.pi/2)**2 + r

        fig = plt.figure()
        ax = fig.add_subplot(111)
        r = []
        #grouped = new_df.groupby('HIP')
        for i, group in enumerate(grouped):
            if i<90000 and group[1].vmag.max() < 4.8:# and group[1].altitude.max() - group[1].altitude.min() > 1:
                c = color[int(group[1].vmag.max()*10)]
                group[1].head()
                x = group[1].sort_values('altitude').altitude.values
                y= (group[1].sort_values('altitude').diff2.values)
                group[1].plot.scatter(ax=ax, x='altitude', y='diff2', c=c)
                inp = (x, group[1].erwartet.values)
                #popt, pcov = curve_fit(quad2, inp, y, p0=[0])
                #popt, pcov = curve_fit(lin, x, y)
                #ax.plot(x, quad2(x,group[1].diff2.max()))
                print(group[1].diff2.max(), group[1].vmag.max())
                #if pcov[0,0] < 0.5:
                #    r.append((popt, group[1].erwartet.max()))
        plt.show()




        plt.hist(np.array(r)[:,0],bins=200, range=(-4,15))

    def logf(x, m, b):
        return 10**(m*x+b)

    fit_stars = df.query('0 < vmag < {}'.format(float(config['image']['vmaglimit'])))
    popt, pcov = curve_fit(logf, fit_stars.vmag.values, fit_stars.response.values, sigma=1/fit_stars.vmag.values, p0=(-0.2, 2))
    x = np.linspace(-3+fit_stars.vmag.min(), fit_stars.vmag.max(), 20)
    y = logf(x, popt[0], popt[1]-0.3)
    lim = (split('\\s*,\\s*', config['image']['visibleupperlimit']), split('\\s*,\\s*', config['image']['visiblelowerlimit']))
    y1 = 10**(x*float(lim[1][0]) + float(lim[1][1]))
    y2 = 10**(x*float(lim[0][0]) + float(lim[0][1]))
    sys.exit(0)


    if args['--response']:
        fig = plt.figure(figsize=(16,9))
        ax = plt.subplot(111)
        ax.axhspan(ymin=11**2/255**2, ymax=13**2/255**2, color='red', alpha=0.5, label='Old threshold - Gradient')
        mean.plot.scatter(x='vmag',y='response', yerr=std['response'].values, color='blue', ax=ax, logy=True, grid=True, vmin=0, vmax=1, label='{} Response'.format(args['--function']))
        #mean.plot.scatter(x='vmag',y='response_grad', yerr=std['response_grad'].values, color='red', ax=ax, logy=True, grid=True, label='Gradient Response')
        #ax.set_xlim((-1, max(mean['vmag'])+0.5))
        ax.set_ylim(bottom=10**(np.log10(np.nanpercentile(mean.response.values,10.0))//1-1),
            top=10**(np.log10(np.nanpercentile(mean.response.values,99.9))//1+1))
        ax.plot(x,y)
        ax.plot(x,y1)
        ax.plot(x,y2)
        ax.legend(loc='best')
        ax.set_ylabel('Kernel Response')
        ax.set_xlabel('Star Magnitude')
        plt.show()
        if args['-s']:
            plt.savefig('response_{}_mean.pdf'.format(args['--function']))
        if args['-v']:
            plt.show()
        plt.close('all')
    
    

    fig = plt.figure(figsize=(16,9))
    ax = plt.subplot(111)
    #if args['--function'] == 'Grad':
    #ax.axhspan(ymin=11**2/255**2, ymax=13**2/255**2, color='red', alpha=0.5, label='old threshold range')
    df.loc[df.index.get_level_values(0).unique()[0]].plot.scatter(
            x='vmag',y='response', color='green', ax=ax, logy=True, grid=True, label='Kernel Response - no Moon')
    df.loc[df.index.get_level_values(0).unique()[1]].plot.scatter(
            x='vmag',y='response', color='red', ax=ax, logy=True, grid=True, label='Kernel Response - Moon')
    df.loc[df.index.get_level_values(0).unique()[2]].plot.scatter(
            x='vmag',y='response', color='k', ax=ax, logy=True, grid=True, label='Kernel Response - cloud')
    ax.set_ylim((1e-5,1))
    plt.show()




''' Main Loop '''
if __name__ == '__main__':
    args = docopt(
        doc=__doc__,
        version=__version__,
        )
    try:
        main(args)
    except (KeyboardInterrupt, SystemExit):
        logging.getLogger().info('Exit')
    except:
        raise
